import re
import struct
import logging
from typing import Dict, List, Union, Optional, Tuple

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("sysgen")

# Extended syscall map with actual syscall IDs for Windows 10 20H2
SYSCALL_MAP = {
    "NtAllocateVirtualMemory": 0x18,
    "NtWriteVirtualMemory": 0x3A,
    "NtCreateThreadEx": 0xC1,
    "NtProtectVirtualMemory": 0x50,
    "NtReadVirtualMemory": 0x3F,
    "NtOpenProcess": 0x26,
    "NtClose": 0x0F,
    "NtQuerySystemInformation": 0x36,
    "NtCreateFile": 0x55,
    "NtDelayExecution": 0x24,
    "NtTerminateProcess": 0x2C,
    "NtCreateSection": 0x4A,
    "NtMapViewOfSection": 0x28,
}

# Valid output formats
VALID_FORMATS = ["go", "c", "hex", "bin"]

# Valid architectures
VALID_ARCHITECTURES = ["x64", "x86"]

def generate_stub(syscalls: List[str], fmt: str, arch: str = "x64") -> Union[str, bytes]:
    """
    Generate syscall stubs in various formats.
    
    Args:
        syscalls: List of syscall names
        fmt: Output format ("go", "c", "hex", "bin")
        arch: Architecture ("x64" or "x86")
    
    Returns:
        Generated stub as string (go/c) or bytes/hex (raw formats)
    
    Raises:
        ValueError: For invalid input
    """
    # Input validation
    if not syscalls:
        logger.error("No syscalls provided")
        raise ValueError("At least one syscall required")
        
    if fmt not in VALID_FORMATS:
        logger.error(f"Invalid format: {fmt}")
        raise ValueError(f"Unsupported format: {fmt}. Valid formats are: {', '.join(VALID_FORMATS)}")
    
    if arch not in VALID_ARCHITECTURES:
        logger.error(f"Invalid architecture: {arch}")
        raise ValueError(f"Unsupported architecture: {arch}. Valid architectures are: {', '.join(VALID_ARCHITECTURES)}")

    # Validate and normalize syscall names
    validated = []
    try:
        for name in syscalls:
            # Skip empty names
            if not name.strip():
                continue
                
            if not re.match(r'^Nt[A-Z][a-zA-Z0-9_]*$', name):
                logger.warning(f"Invalid syscall name format: {name}")
                raise ValueError(f"Invalid syscall name: {name}. Names must start with 'Nt' followed by a capital letter.")
                
            if name not in SYSCALL_MAP:
                logger.warning(f"Unknown syscall: {name}")
                raise ValueError(f"Unknown syscall: {name}. Add it to SYSCALL_MAP first.")
                
            validated.append(name)
    except Exception as e:
        logger.error(f"Validation error: {str(e)}")
        raise

    if not validated:
        logger.error("No valid syscalls after validation")
        raise ValueError("No valid syscalls provided")

    logger.info(f"Generating {fmt} stub for {len(validated)} syscalls with {arch} architecture")
    
    # Dispatch to appropriate generator
    try:
        if fmt == "go":
            return _generate_go_stub(validated, arch)
        elif fmt == "c":
            return _generate_c_stub(validated, arch)
        elif fmt == "hex":
            return _generate_raw_stub(validated, arch).hex()
        elif fmt == "bin":
            return _generate_raw_stub(validated, arch)
    except Exception as e:
        logger.error(f"Error generating stub: {str(e)}")
        raise ValueError(f"Failed to generate {fmt} stub: {str(e)}")

def _generate_go_stub(syscalls: List[str], arch: str) -> str:
    """
    Generate Go language syscall stubs.
    
    Args:
        syscalls: List of validated syscall names
        arch: Target architecture
        
    Returns:
        Generated Go code as string
    """
    header = f"""// Code generated by GoWhispers - DO NOT EDIT
// Architecture: {arch}
// Generated syscalls: {', '.join(syscalls)}

package main

import (
    "syscall"
    "unsafe"
)

var (
    modntdll = syscall.NewLazyDLL("ntdll.dll")
"""
    
    procs = [f'    proc{syscall} = modntdll.NewProc("{syscall}")' 
            for syscall in syscalls]
    
    functions = []
    for syscall in syscalls:
        # Improved function template with parameter placeholders that can be customized
        functions.append(f"""
// {syscall} executes the {syscall} syscall
func {syscall}() uintptr {{
    ret, _, _ := proc{syscall}.Call()
    return ret
}}""")

    return header + "\n".join(procs) + "\n)\n" + "\n".join(functions)

def _generate_c_stub(syscalls: List[str], arch: str) -> str:
    """
    Generate C language syscall stubs.
    
    Args:
        syscalls: List of validated syscall names
        arch: Target architecture
        
    Returns:
        Generated C code as string
    """
    header = f"""// Code generated by GoWhispers - DO NOT EDIT
// Architecture: {arch}
// Generated syscalls: {', '.join(syscalls)}

#include <windows.h>
#include <winternl.h>

"""
    
    stubs = []
    for syscall in syscalls:
        syscall_id = SYSCALL_MAP[syscall]
        
        if arch == "x86":
            stub = f"""__declspec(naked) NTSTATUS {syscall}() {{
    __asm {{
        mov eax, 0x{syscall_id:X}
        mov edx, 0x7FFE0300
        call dword ptr [edx]
        ret
    }}
}}
"""
        else:  # x64
            stub = f"""__declspec(naked) NTSTATUS {syscall}() {{
    __asm {{
        mov r10, rcx
        mov eax, 0x{syscall_id:X}
        syscall
        ret
    }}
}}
"""
        stubs.append(stub)

    return header + "\n".join(stubs)

def _generate_raw_stub(syscalls: List[str], arch: str) -> bytes:
    """
    Generate actual shellcode for the syscalls.
    
    Args:
        syscalls: List of validated syscall names
        arch: Target architecture
        
    Returns:
        Compiled shellcode as bytes
    """
    shellcode = bytearray()
    
    for syscall in syscalls:
        syscall_id = SYSCALL_MAP[syscall]
        
        if arch == "x86":
            # x86 syscall stub
            code = bytes.fromhex(f"B8{syscall_id:08X}BA0003FE7FFFD2C3")
        else:  # x64
            # x64 syscall stub
            code = bytes.fromhex(f"4989CAB8{syscall_id:08X}0F05C3")
        
        shellcode.extend(code)
    
    return bytes(shellcode)

def add_syscall(name: str, syscall_id: int) -> bool:
    """
    Add a custom syscall to the SYSCALL_MAP.
    
    Args:
        name: Syscall name (must start with Nt followed by a capital letter)
        syscall_id: Syscall ID in integer format
        
    Returns:
        True if syscall was added successfully, False otherwise
        
    Raises:
        ValueError: If inputs are invalid
    """
    # Validate syscall name
    if not re.match(r'^Nt[A-Z][a-zA-Z0-9_]*$', name):
        logger.warning(f"Invalid syscall name format: {name}")
        raise ValueError(f"Invalid syscall name: {name}. Names must start with 'Nt' followed by a capital letter.")
    
    # Validate syscall ID
    if not isinstance(syscall_id, int) or syscall_id < 0 or syscall_id > 0xFFF:
        logger.warning(f"Invalid syscall ID: {syscall_id}")
        raise ValueError("Syscall ID must be a positive integer less than 0x1000")
    
    # Add to map
    SYSCALL_MAP[name] = syscall_id
    logger.info(f"Added syscall {name} with ID 0x{syscall_id:X} to SYSCALL_MAP")
    return True

def get_all_syscalls() -> Dict[str, int]:
    """
    Get all available syscalls.
    
    Returns:
        Dictionary of syscall names and their IDs
    """
    return dict(SYSCALL_MAP)

def get_syscall_id(name: str) -> Optional[int]:
    """
    Get the ID for a specific syscall name.
    
    Args:
        name: Syscall name
        
    Returns:
        Syscall ID or None if not found
    """
    return SYSCALL_MAP.get(name)

# If this module is run directly, print all available syscalls
if __name__ == "__main__":
    print("Available syscalls:")
    for name, id in sorted(SYSCALL_MAP.items()):
        print(f"  {name}: 0x{id:X}")